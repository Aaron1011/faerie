#![allow(unused_variables)]
#![allow(dead_code)]

use {error, Artifact, Target, Object, Code, Data, Ctx};

//use ordermap::OrderMap;
//use std::collections::HashMap;
use std::io::{Seek, Cursor, BufWriter, Write};
use std::io::SeekFrom::*;
use scroll::{Pwrite, IOwrite};
use scroll::ctx::SizeWith;

use goblin::mach::cputype;
use goblin::mach::segment;
use goblin::mach::load_command::SymtabCommand;
use goblin::mach::header::{Header, MH_OBJECT, MH_SUBSECTIONS_VIA_SYMBOLS};
use goblin::mach::symbols::Nlist;
use goblin::mach::relocation::{RelocationInfo, RelocType};

type Section = segment::Section;
type Segment<'a> = segment::Segment<'a>;

struct CpuType(cputype::CpuType);

impl From<Target> for CpuType {
    fn from(target: Target) -> CpuType {
        use self::Target::*;
        use mach::cputype::*;
        CpuType(match target {
            X86_64 => CPU_TYPE_X86_64,
            X86 => CPU_TYPE_X86,
            ARM64 => CPU_TYPE_ARM64,
            ARMv7 => CPU_TYPE_ARM,
            Unknown => 0
        })
    }
}

pub type StrTable = Vec<String>;

pub type SectionIndex = usize;
pub type StrtableOffset = usize;

/// A builder for creating a 32/64 bit Mach-o Nlist symbol
#[derive(Debug)]
pub struct SymbolBuilder {
    name: StrtableOffset,
    section: Option<SectionIndex>,
    global: bool,
    import: bool,
}

impl SymbolBuilder {
    /// Create a new symbol with `typ`
    pub fn new(name: StrtableOffset) -> Self {
        SymbolBuilder {
            name,
            section: None,
            global: false,
            import: false,
        }
    }
    /// The section this symbol belongs to
    pub fn section(mut self, section_index: SectionIndex) -> Self {
        self.section = Some(section_index); self
    }
    /// Is this symbol global?
    pub fn global(mut self) -> Self {
        self.global = true; self
    }
    /// Is this symbol an import?
    pub fn import(mut self) -> Self {
        self.import = true; self
    }
    /// Finalize and create the symbol
    /// The n_value (offset into section) is still unset, and needs to be generated by the client
    pub fn create(self) -> Nlist {
        use goblin::mach::symbols::{N_EXT, N_UNDF, N_SECT, NO_SECT};
        let n_strx = self.name;
        let mut n_sect = 0;
        let mut n_type = N_UNDF;
        // FIXME:
        let n_value = 0;
        let n_desc = 0;
        if self.global {
            n_type |= N_EXT;
        } else {
            n_type &= !N_EXT;
        }
        if let Some(idx) = self.section {
            n_sect = idx + 1; // add 1 because n_sect expects ordinal
            n_type |= N_SECT;
        }

        if self.import {
            n_sect = NO_SECT as usize;
            // FIXME: this is broken i believe; we need to make it both undefined + global for imports
            n_type = N_EXT;
        } else {
            n_type |= N_SECT;
        }

        Nlist {
            n_strx,
            n_type,
            n_sect,
            n_desc,
            n_value
        }
    }
}

/// An index into the symbol table
pub type SymbolIndex = usize;

/// Mach relocation builder
#[derive(Debug)]
pub struct RelocationBuilder {
    symbol: SymbolIndex,
    section_relative_offset: usize,
    absolute: bool,
    r_type: RelocType,
}

impl RelocationBuilder {
    /// Create a relocation for `symbol`, starting at `section_relative_offset`
    pub fn new(symbol: SymbolIndex, section_relative_offset: usize, r_type: RelocType) -> Self {
        RelocationBuilder {
            symbol,
            section_relative_offset,
            absolute: false,
            r_type,
        }
    }
    /// This is an absolute relocation
    pub fn absolute(mut self) -> Self {
        self.absolute = true; self
    }
    /// Finalize and create the relocation
    pub fn create(self) -> RelocationInfo {
        let r_symbolnum: u32 = (self.symbol as u32) << 8;
        let r_pcrel: u32 = if self.absolute { 1 } else { 0} << 7;
        let r_length: u32 = if self.absolute { 3 } else { 2 } << 5;
        let r_extern: u32 = 1 << 4;
        let r_type = self.r_type as u32;
        // r_symbolnum, 24 bits, r_pcrel 1 bit, r_length 2 bits, r_extern 1 bit, r_type 4 bits
        let r_info = r_symbolnum | r_pcrel | r_length | r_extern | r_type;
        RelocationInfo {
            r_address: self.section_relative_offset as i32,
            r_info,
        }
    }
}

/// Helper to build sections
#[derive(Debug, Clone)]
pub struct SectionBuilder {
    addr: usize,
    align: usize,
    offset: usize,
    size: usize,
    sectname: &'static str,
    segname: &'static str,
}

impl SectionBuilder {
    pub fn new(sectname: &'static str, segname: &'static str, size: usize) -> Self {
        SectionBuilder {
            addr: 0,
            align: 4,
            offset: 0,
            size,
            sectname,
            segname,
        }
    }
    /// Set the vm address of this section
    pub fn addr(mut self, addr: usize) -> Self {
        self.addr = addr; self
    }
    /// Set the file offset of this section
    pub fn offset(mut self, offset: usize) -> Self {
        self.offset = offset; self
    }
    /// Set the alignment of this section
    pub fn align(mut self, align: usize) -> Self {
        self.align = align; self
    }
    /// Finalize and create the actual Mach-o section
    pub fn create(self) -> Section {
        let mut sectname = [0u8; 16];
        sectname.pwrite(self.sectname, 0).unwrap();
        let mut segname = [0u8; 16];
        segname.pwrite(self.segname, 0).unwrap();
        Section {
            sectname,
            segname,
            addr: self.addr as u64,
            size: self.size as u64,
            offset: self.offset as u32,
            align: self.align as u32,
            // FIXME, client needs to set after all offsets known
            reloff: 0,
            nreloc: 0,
            flags: 2147484672
        }
    }
}

type ArtifactCode = Vec<(String, Code)>;
type ArtifactData = Vec<(String, Data)>;
type ArtifactImports = Vec<String>;

type Sections = [SectionBuilder; 2];

/// A mach-o object file container
#[derive(Debug)]
pub struct Mach<'a> {
    ctx: Ctx,
    target: Target,
    code: ArtifactCode,
    data: ArtifactData,
    imports: ArtifactImports,
    _p: ::std::marker::PhantomData<&'a ()>,
    sections: Vec<SectionBuilder>,
    symbols: Vec<SymbolBuilder>,
    strtable: Vec<String>,
    strtable_size: StrtableOffset,
    segment_offset: usize,
    segment_size: usize,
}

impl<'a> Mach<'a> {
    //pub fn new(name: Option<String>, target: Target) -> Self {
    pub fn new(artifact: &Artifact) -> Self {
        let target = artifact.target.clone();
        let ctx = Ctx::from(target);
        let name = artifact.name.clone();
        let code = artifact.code.clone();
        let data = artifact.data.clone();
        let imports = artifact.imports.clone();
        Mach {
            ctx,
            target,
            sections: Vec::new(),
            symbols: Vec::new(),
            // first strtable entry (like ELF) is always nothing
            strtable: vec!["".to_string()],
            strtable_size: 1,
            segment_offset: 0,
            segment_size: 0,
            code,
            data,
            imports,
            _p: ::std::marker::PhantomData::default(),
        }
    }
    fn build_section(&mut self, sectname: &'static str, segname: &'static str, offset: &mut usize, addr: &mut usize, section: SectionIndex, raw: & [(String, Vec<u8>)]) -> SectionBuilder {
        let mut size = 0;
        for &(ref name, ref code) in raw {
            let name = format!("_{}", name);
            // for null terminator;
            self.strtable_size += name.len() + 1;
            let builder = SymbolBuilder::new(self.strtable_size).global().section(section);
            self.strtable.push(name);
            self.symbols.push(builder);
            size += code.len();
        }
        let section = SectionBuilder::new(sectname, segname, size).offset(*offset).addr(*addr);
        *offset += size;
        *addr += size;
        section
    }
    fn sections(&mut self, code: &ArtifactCode, data: &ArtifactData, imports: &ArtifactImports) -> Sections {
        let mut offset = Header::size_with(&self.ctx.container);
        let mut addr = 0;
        let text = self.build_section("__text", "__TEXT", &mut offset, &mut addr, 0,&code);
        let data = self.build_section("__data", "__DATA", &mut offset, &mut addr, 1,&data);
        for name in imports {
            let name = format!("_{}", name);
            let builder = SymbolBuilder::new(self.strtable_size).global().import();
            // for null terminator;
            self.strtable_size += name.len() + 1;
            self.strtable.push(name);
            self.symbols.push(builder);
        }
        self.segment_offset = offset;
        self.segment_size = addr;
        debug!("Section offset: {} - Segment Size: {} Symtable Offset: {}", offset, addr, offset + addr);
        [text, data]
    }
    fn header(&self) -> Header {
        let mut header = Header::new(&self.ctx);
        header.filetype = MH_OBJECT;
        // safe to divide up the sections into sub-sections via symbols for dead code stripping
        header.flags = MH_SUBSECTIONS_VIA_SYMBOLS;
        header.cputype = CpuType::from(self.target).0;
        header.cpusubtype = 3;
        header.ncmds = 2;
        header
    }
    pub fn write<T: Write + Seek>(self, file: T, sections: Sections) -> error::Result<()> {
        let mut file = BufWriter::new(file);
        let ctx = self.ctx.clone();
        let header = self.header();

        let mut raw_sections = Cursor::new(Vec::<u8>::new());
        for section in sections.into_iter().cloned() {
            let section: Section = section.create();
            debug!("Section: {:#?}", section);
            raw_sections.iowrite_with(section, self.ctx)?;
        }
        let raw_sections = raw_sections.into_inner();
        debug!("Raw sections len: {} - Section start: {} Strtable size: {}", raw_sections.len(), self.segment_offset, self.strtable_size);
        // section start == segment start == code start
        //let sections = self.sections()

        let mut segment_load_command = Segment::new(self.ctx, &raw_sections);
        segment_load_command.nsects = sections.len() as u32;
        // FIXME: de-magic number these
        segment_load_command.initprot = 7;
        segment_load_command.maxprot = 7;
        segment_load_command.filesize = self.segment_size as u64;
        segment_load_command.vmsize = segment_load_command.filesize;
        segment_load_command.fileoff = self.segment_offset as u64;
        debug!("Segment: {:#?}", segment_load_command);

        // construct symtab command
        let mut symtab_load_command = SymtabCommand::new();
        let symtable_offset = self.segment_offset + segment_load_command.cmdsize as usize + symtab_load_command.cmdsize as usize;
        debug!("Symtable Offset: {:#?}", symtable_offset);
        symtab_load_command.nsyms = self.symbols.len() as u32;
        symtab_load_command.symoff = symtable_offset as u32;
        symtab_load_command.stroff = (symtable_offset + (self.symbols.len() * Nlist::size_with(&self.ctx))) as u32;
        symtab_load_command.strsize = self.strtable_size as u32;

        debug!("Symtab Load command: {:#?}", symtab_load_command);

        //////////////////////////////
        // write header
        //////////////////////////////
        file.iowrite_with(header, ctx)?;
        debug!("SEEK: after header: {}", file.seek(Current(0))?);

        //////////////////////////////
        // write load commands
        //////////////////////////////
        file.iowrite_with(segment_load_command, ctx)?;
        file.write(&raw_sections)?;
        file.iowrite_with(symtab_load_command, ctx.le)?;
        debug!("SEEK: after load commands: {}", file.seek(Current(0))?);

        //////////////////////////////
        // write code
        //////////////////////////////
        for (_, code) in self.code {
            file.write(&code)?;
        }
        debug!("SEEK: after code: {}", file.seek(Current(0))?);

        //////////////////////////////
        // write data
        //////////////////////////////
        for (_, data) in self.data {
            file.write(&data)?;
        }
        debug!("SEEK: after data: {}", file.seek(Current(0))?);

        //////////////////////////////
        // write symtable
        //////////////////////////////
        for symbol in self.symbols.into_iter() {
            file.iowrite_with(symbol.create(), self.ctx)?;
        }
        debug!("SEEK: after symtable: {}", file.seek(Current(0))?);

        //////////////////////////////
        // write strtable
        //////////////////////////////
        for string in self.strtable.into_iter() {
            file.write(string.as_bytes())?;
            file.iowrite(0u8)?;
        }
        debug!("SEEK: after strtable: {}", file.seek(Current(0))?);

        //////////////////////////////
        // write relocations
        //////////////////////////////
        debug!("SEEK: after relocations: {}", file.seek(Current(0))?);

        file.iowrite(0u8)?;

        Ok(())
    }
}

impl<'a> Object for Mach<'a> {
    fn to_bytes(artifact: &Artifact) -> error::Result<Vec<u8>> {
        //let mach = Mach::new(Some(artifact.name.to_string()), artifact.target.clone());
        let mut mach = Mach::new(&artifact);
        let sections = mach.sections(&artifact.code, &artifact.data, &artifact.imports);
        debug!("Post sections: {:#?}", mach);
        let mut buffer = Cursor::new(Vec::new());
        mach.write(&mut buffer, sections)?;
        Ok(buffer.into_inner())
    }
}
